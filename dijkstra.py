# -*- coding: utf-8 -*-
"""Dijkstra.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/151Fow8VUeKmA2UsMObUdvk3p5U6u5Di6

<center><img src="https://drive.google.com/uc?id=17-N_4cqBA_H9BKKVgTeZDuhCgwVKSH8s" width="300" height="150" ></center>
"""

# 경로 그래프를 만든다.
graph = (['start','A', 6],['start','B', 2], ['A', 'finish', 1], ['B', 'finish', 5], ['B', 'A', 3])
graph

'''
노드 집합을 만든다.
노드 집합에서 노드를 꺼내 방문하기 시작한다. 방문한 노드는 visits로 옮긴다.
nodes에 있는 모든 노드가 visits로 이동하면 알고리즘이 끝난다.
'''
nodes = set()
for node in graph:
    nodes.add(node[0])
    nodes.add(node[1])
nodes

# 방문한 노드를 기록하기 위한 집합을 만든다.
visits = set()

# 각 노드는 출발점과의 거리와 최적경로를 만족하는 부모노드를 지정해야 한다.
# 처음에는 최적경로를 모르므로 모든 노드와 거리는 무한대로 설정하고 각 노드의 부모노드는 "모름"으로 설정한다.

cost = {}

for node in nodes:
    cost[node] = [float("inf"), None]  # [노드까지 가는 비용, 부모노드]

# 시작과 끝 노드를 정의한다.
start = 'start'
end = 'finish'

# 시작노드의 거리는 0으로 설정한다.
curNode = start
cost[curNode][0] = 0

print(cost)

# curNode에서 갈 수 있는 노드를 반환하는 함수다.
# 'start'에서 갈 수 있는 노드는 'A', 'B' 다.

def _neighbor(curNode):
    # curNode에 연결된 이웃노드를 리스트로 리턴한다.
    neighbor = {}
    for node in graph:
        if node[0] == curNode:
            neighbor[node[1]] = node[2]
        elif node[1] == curNode:
            neighbor[node[0]] = node[2]
    return neighbor

neighbors = _neighbor(curNode)
neighbors

# 그래프에서 노드 n1, n2의 가중값을 리턴한다.
def _getWeight(n1, n2):
    for node in graph:
        if (node[0] == n1 and node[1] == n2) or (node[0] == n2 and node[1] == n1):
            return node[2]
    return None

# curNode를 방문처리한다.
visits.add(curNode)
nodes.remove(curNode)   # 안 가본 노드

visits, nodes

# 모든 이웃에 대해 현재 노드를 통해 이웃노드에 접근하는 cost가 더 작을 경우, cost 값을 갱신하고 부모노드를 변경한다.
# 'A': [6, 'start'] 는 'A'에 'start'를 통해 접근할 경우, cost가 6이란 의미다.
# 만약, 'A'에 다른 노드를 통해 접근할 때 더 작은 cost가 있다면 갱신한다.
# curNode에서 갈 수 있는 모든 이웃에 대해
# curNode를 통해 node로 가는 비용은 curNode까지 오는 비용 + curNode에서 node 까지 가는 비용이므로
# cost[curNode][0] + _getWeight(curNode,node)가 된다.
# 이 비용이 현재시점에서 알고있는 node 비용보다 작다면 node의 비용과 parent 노드를 curNode를 통해 가는 것으로 갱신한다.
# 초기 cost는 {'start': [0, None], 'B': [inf, None], 'A': [inf, None], 'finish': [inf, None]} 이다.
# 현재 노드의 이웃노드를 하나씩 꺼낸다.

for node in neighbors:
    if cost[curNode][0] + _getWeight(curNode,node) < cost[node][0]:
        cost[node][0] = cost[curNode][0] + _getWeight(curNode, node)
        cost[node][1] = curNode

print(curNode, nodes)
print(cost)

"""* 다시 nodes 집합 {'finish', 'B', 'A'} 중에 최소 비용을 가지는 노드를 curNode로 선정하고 위 과정을 반복한다.
   여기서는 B가 선택된다.
* 이를 위해서는 cost에서 nodes에 있는 키를 대상으로 최소비용노드를 선택해야 한다.
* 딕셔너리 부분집합을 정의하기 위해 아래의 코드를 사용할 수 있다.<br>

"""

# 딕셔너리 필터는 nodes에서 cost가 최소인 노드를 찾아 리턴한다.
# cost 중에 현재 노드에서 이동가능한 노드만 cost가 갱신 되어 있으므로 최소노드는 이동 가능한 노드 중에만 선택된다.
def dicFilter(cost, nodes):
    import sys
    mini = sys.maxsize       # 컴퓨터가 기억할 수 있는 최대값
    for key, value in cost.items():
        if key in nodes:
            if value[0] < mini:
                mini = value[0]
                curNode = key
    return curNode

print(cost, nodes)
curNode = dicFilter(cost, nodes)
curNode

# 'B'에서 갈 수 있는 노드는 'A', 'finish' 다.
print(curNode)
visits.add(curNode)
nodes.remove(curNode)
neighbors = _neighbor(curNode)
print(neighbors)

# 모든 이웃에 대해 현재 노드를 통해 이웃노드에 접근하는 cost가 더 작을 경우, dist 값을 갱신하고 부모노드를 변경한다.
# 'A' 로 갈 수 있는 방법이 'start'에서 직접 가는 것 보다 'B'를 통과해 가는 것이 비용이 작아 'A'의 비용과 부모노드가 갱신되었다.

for node in neighbors:
    if cost[curNode][0] + _getWeight(curNode,node) < cost[node][0]:
        cost[node][0] = cost[curNode][0] + _getWeight(curNode, node)
        cost[node][1] = curNode
print(curNode, nodes)
print(cost)

# {'finish', 'A'} 중에 비용이 작은 노드는 'A'다.
curNode = dicFilter(cost, nodes)
print(curNode)

neighbors = _neighbor(curNode)
print(neighbors)

visits.add(curNode)
nodes.remove(curNode)

for node in neighbors:
    if cost[curNode][0] + _getWeight(curNode,node) < cost[node][0]:
        cost[node][0] = cost[curNode][0] + _getWeight(curNode, node)
        cost[node][1] = curNode
print(curNode, nodes)
print(cost)


class Dijkstra:
    def __init__(self,nodes):
        self.g = {}
        self.dist = {}
        for node in nodes:
            self.g[node] = {}
            self.dist[node] = [float("inf"), "none"]

    def setEdge(self,a,b,w,bidirection=True):
        self.g[a][b] = w
        if bidirection == True: self.g[b][a] = w

    def getPath(self,start,end):
        dictfilt = lambda x, y: dict([(i, x[i]) for i in x if i in set(y)])
        visits = set()
        curNode = start
        self.dist[curNode][0] = 0
        while True:
            visits.add(curNode)
            nodes.remove(curNode)
            neighbors = self.g[curNode]

            for node in neighbors:
                if min(self.dist[node][0], self.dist[curNode][0] + self.g[curNode][node]) < self.dist[node][0]:
                    self.dist[node][0] = min(self.dist[node][0], self.dist[curNode][0] + self.g[curNode][node])
                    self.dist[node][1] = curNode

            if len(nodes) > 0:
                curNode = min(dictfilt(self.dist, nodes), key=dictfilt(self.dist, nodes).get)
            else:
                break

        path = [end]
        dist = []

        while end != start:
            path.append(self.dist[end][1])
            dist.append(self.dist[end][0])
            end = self.dist[end][1]

        return path[::-1], dist[::-1]

"""<center><img src="https://drive.google.com/uc?id=1ld8EGLdOA37raFZwAx5xzeLtuSLqmhDv" width="400" height="300" ></center>"""

graph = [(0, 1, 7), (0, 4, 3), (0, 5, 10), (1, 2, 4), (1, 4, 2),
         (1, 5, 6), (1, 3, 10), (2, 3, 2),(3, 5, 9), (3, 6, 4), (4, 6, 5)]

nodes = set()
for node in graph:
    nodes.add(node[0])
    nodes.add(node[1])
print(nodes)

d = Dijkstra(nodes)

for node in graph:
    d.setEdge(node[0], node[1], node[2])

d.getPath(0, 3)

